# 设计模式的一些例子代码

设计模式可以分为三大类创建型、结构型、行为型，常见模式共有二十三种，这里列出有十一个。

## 创建型模式

它是类实例化过程的抽象，将类的创建和对象的使用分离，单一指责原则。

 - 单例模式
 - 工厂模式
 - 建造者模式

单例模式是一个创建型模式，它确保一个类只有一个实例，并可以自实例化，向整个系统提供，用于全局可以共用一个实例的场景，例如 工具类、常用方法、打印机队列等

工厂模式是一个创建型模式，它提供一个抽象工厂类来约定一个创建接口，在具体工厂类中实现具体产品的创建、这样使用时不需要知道具体的产品对象只需要知道具体工厂即可创建对应的产品。它包含抽象工厂类、具体工厂类、抽象产品类、具体产品类

建造者模式是一个创建型模式，是用于创建对象比较复杂，可以分成一步步创建完，且这类产品都有相同的创建步骤。
## 结构型模式

将类或对象结合在一起形成一个更大的结构，用法上可分为关联和继承。

   - 适配器模式
   - 装饰模式
   - 代理模式
   - 外观模式
   - 桥接模式

适配器模式是一个结构型模式，它主要把一个接口转换成另一个接口，一般是客户端使用的方法在旧对象不存在，需要增加一个适配类来转换。它是提供一个新的类

装饰模式是一个结构型模式，它动态的给一个对象增加额外的职责，通过将一个对象嵌入另一个对象中扩展行为。

代理模式是一个结构型模式，它给一个对象提供一个代理，并由代理来控制对象对原对象的引用。

外观模式是一个结构型模式，它定义外部与子系统的通讯必须通过一个统一的外观对象进行，为子系统一组接口提供统一界面。减少客户类和子系统的耦合。

桥接模式是一个结构型模式，它把二个维度的类组合使用，比如播放器有不同平台、可以不放不同格式视频
将抽象部分与实现部分分离，是他们独立的变化。通过关联组合使用类来降低类与类的耦合

对于有两个维度变化的系统，通过组合使用来减少类的数量和类之间的耦合，让系统的扩展方便，一般会会把这两个维度分为抽象部分和实现部分，他们都可以独立变化

## 行为型模式

它是对不同对象之间划分责任和算法的抽象化，描述对象之间的行为相互影响变化

- 观察者模式
- 状态模式
- 策略模式

观察者模式是一个行为型模式，它定义对象间一种一对多的关系，使得每当一个对象状态发生变化，与之关联的对象都能收到通知。

状态模式是一个行为型模式，它允许一个对象在其内部状态改变时改变它的行为。一个对象的行为取决于一个属性的变化，这样的对象叫有状态的对象，这样的对象在因外部改变状态时，其内部行为也会随着状态的改变而改变

策略模式是一个行为型模式，它提供一些列算法，并将每个算法封装起来，可以让他们互现切换。它包括一个环境上下文类、一个抽象策略类，具体的策略实现类。它让每个类封装一个算法，使用可以灵活的选择不同的算法

## 类关系

共有六种类关系，依次如下：

泛化关系，用一条带空心箭头的实线表示，表现为继承非抽象类
实现关系，用一条带空心箭头的虚线表示，表现为继承抽象类（或接口）

聚合关系，用一条带空心菱形箭头的实线表示，表示整体由部分组成，但整体不存在则部分依然存在，如：部门由多个员工组成
组合关系，用一条带实心菱形箭头的实线表示，表示整体由部分组成，但整体不存在则部分也不存在，如：公司由多个部门组成

关联关系，用一条带箭头的实线表示，表现为类的成员变量
依赖关系，用一条带箭头的虚线表示，表现为构造函数的参数


## 项目中用过的模式

门面模式

用于实现页面使用多个组件时，提供一个门面类统一管理使用的组件

单例模式

用来定义全局使用的对象，提供便捷使用的方法，utils

代理模式

封装 fetch 方法，提供统一自定义的 service 层接口，方便统一管理和更替第三方库

观察者模式

用来实现组件间消息通知，

## 七大原则

* 开闭原则，对扩展开发、对修改关闭
* 里氏替换原则，子类能扩展但不能修改父类的方法
* 依赖倒置原则，高层不应该依赖低层，应该依赖其抽象接口
* 单一职责原则，一个类有且仅有一个引起它变化的原因
* 接口隔离原则，尽量将大的接口拆分成小的和更具体的接口
* 迪米特法则，一个类应该保持对其他类的最少了解
* 合成复用原则，软件复用时，尽量使用组合聚合来实现，其次才使用继承